/**
 * Base implementation of engine pipeline step.
 */
import { IFileSystem } from "unitejs-framework/dist/interfaces/IFileSystem";
import { ILogger } from "unitejs-framework/dist/interfaces/ILogger";
import { UniteConfiguration } from "../configuration/models/unite/uniteConfiguration";
import { IPipelineStep } from "../interfaces/IPipelineStep";
import { EngineVariables } from "./engineVariables";
import { MarkerState } from "./markerState";

export abstract class PipelineStepBase implements IPipelineStep {
    public static MARKER: string = "Generated by UniteJS";

    public mainCondition(uniteConfiguration: UniteConfiguration, engineVariables: EngineVariables): boolean | undefined {
        return undefined;
    }

    public async initialise(logger: ILogger,
                            fileSystem: IFileSystem,
                            uniteConfiguration: UniteConfiguration,
                            engineVariables: EngineVariables): Promise<number> {
        return 0;
    }

    public async install(logger: ILogger,
                         fileSystem: IFileSystem,
                         uniteConfiguration: UniteConfiguration,
                         engineVariables: EngineVariables): Promise<number> {
        return 0;
    }

    public async uninstall(logger: ILogger,
                           fileSystem: IFileSystem,
                           uniteConfiguration: UniteConfiguration,
                           engineVariables: EngineVariables): Promise<number> {
        return 0;
    }

    public async finalise(logger: ILogger,
                          fileSystem: IFileSystem,
                          uniteConfiguration: UniteConfiguration,
                          engineVariables: EngineVariables): Promise<number> {
        return 0;
    }

    public async copyFile(logger: ILogger,
                          fileSystem: IFileSystem,
                          sourceFolder: string,
                          sourceFilename: string,
                          destFolder: string,
                          destFilename: string,
                          force: boolean,
                          replacements?: { [id: string]: string[]}): Promise<number> {
        const sourceFileExists = await fileSystem.fileExists(sourceFolder, sourceFilename);

        if (sourceFileExists) {
            const hasGeneratedMarker = await this.fileHasGeneratedMarker(fileSystem, destFolder, destFilename);

            if (hasGeneratedMarker === "FileNotExist" || hasGeneratedMarker === "HasMarker" || force) {
                logger.info(`Copying ${sourceFilename}`, { from: sourceFolder, to: destFolder });

                try {
                    // We recombine this as sometimes the filename contains more folders
                    const folderWithFile = fileSystem.pathCombine(destFolder, destFilename);
                    const folderOnly = fileSystem.pathGetDirectory(folderWithFile);
                    const dirExists = await fileSystem.directoryExists(folderOnly);
                    if (!dirExists) {
                        await fileSystem.directoryCreate(folderOnly);
                    }

                    let txt = await fileSystem.fileReadText(sourceFolder, sourceFilename);
                    if (replacements) {
                        Object.keys(replacements).forEach(replacementKey => {
                            txt = txt.replace(`{${replacementKey}}`, replacements[replacementKey].join("\r\n"));
                        });
                    }
                    await fileSystem.fileWriteText(destFolder, destFilename, txt);
                } catch (err) {
                    logger.error(`Copying ${sourceFilename} failed`, err, { from: sourceFolder, to: destFolder });
                    return 1;
                }
            } else {
                logger.info(`Skipping ${sourceFilename} as it has no generated marker`,
                            { from: sourceFolder, to: destFolder });
            }
            return 0;
        } else {
            logger.error(`${sourceFilename} does not exist`,
                         { folder: sourceFolder, file: sourceFilename });
            return 1;
        }
    }

    public async deleteFile(logger: ILogger, fileSystem: IFileSystem,
                            folder: string, filename: string, force: boolean): Promise<number> {
        const hasGeneratedMarker = await this.fileHasGeneratedMarker(fileSystem, folder, filename);

        if (hasGeneratedMarker === "HasMarker" || (hasGeneratedMarker !== "FileNotExist" && force)) {
            try {
                logger.info(`Deleting ${filename}`, { from: folder });
                await fileSystem.fileDelete(folder, filename);
                return 0;
            } catch (err) {
                logger.error(`Deleting ${filename} failed`, err);
                return 1;
            }
        } else if (hasGeneratedMarker === "NoMarker") {
            logger.info(`Skipping Delete of ${filename} as it has no generated marker`, { from: folder });
            return 0;
        } else {
            return 0;
        }
    }

    public wrapGeneratedMarker(before: string, after: string): string {
        return before + PipelineStepBase.MARKER + after;
    }

    public async fileHasGeneratedMarker(fileSystem: IFileSystem, folder: string, filename: string): Promise<MarkerState> {
        let markerState: MarkerState = "FileNotExist";

        try {
            const exists = await fileSystem.fileExists(folder, filename);
            if (exists) {
                const existingLines = await fileSystem.fileReadLines(folder, filename);
                // Test the last few lines in case there are line breaks
                let hasMarker = false;
                for (let i = existingLines.length - 1; i >= 0 && i >= existingLines.length - 5 && !hasMarker; i--) {
                    hasMarker = existingLines[i].indexOf(PipelineStepBase.MARKER) >= 0;
                }

                markerState = hasMarker ? "HasMarker" : "NoMarker";
            }
            return markerState;
        } catch (err) {
            return markerState;
        }
    }

    public condition(uniteConfigurationKey: string, value: string): boolean {
        return uniteConfigurationKey !== undefined &&
            uniteConfigurationKey !== null &&
            value !== undefined &&
            value !== null &&
            uniteConfigurationKey.toLowerCase() === value.toLowerCase();
    }

    public objectCondition(uniteConfigurationObject: any, value: string): boolean {
        return uniteConfigurationObject !== undefined &&
            uniteConfigurationObject !== null &&
            value !== undefined &&
            value !== null &&
            Object.keys(uniteConfigurationObject).map(key => key.toLowerCase()).indexOf(value.toLowerCase()) >= 0;
    }
}
